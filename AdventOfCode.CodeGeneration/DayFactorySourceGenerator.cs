using System.Collections.Generic;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace AdventOfCode.CodeGeneration
{
    [Generator]
    public class DayFactorySourceGenerator : ISourceGenerator
    {
        public void Initialize(GeneratorInitializationContext context)
        {
        }

        public void Execute(GeneratorExecutionContext context)
        {
            var type = context.Compilation.GetTypeByMetadataName("AdventOfCode.DayFactory");

            var classNames = GetDayClassNames(context)
                .Select(x => int.Parse(x.Replace("Day", "")))
                .OrderBy(x => x)
                .Select(x => $"{x} => new AdventOfCode.Year2022.Day{x}.Day{x}(),");

            // Build up the source code
            string source = $@"// <auto-generated/>
namespace {type.ContainingNamespace.ToDisplayString()}
{{
    internal partial class {type.Name}
    {{
        public IDay GeneratedMethod(int day)
            => day switch
            {{
                {string.Join("\r\n                ", classNames)}
                _ => throw new NotImplementedException(
                    $""Solution for day: {{day}} is not implemented"")
            }};
    }}
}}
";
            var typeName = type.Name;

            // Add the source code to the compilation
            context.AddSource($"{typeName}.g.cs", source);
        }

        private static IEnumerable<string> GetDayClassNames(GeneratorExecutionContext context)
            => context.Compilation.SyntaxTrees
                .Where(x => x.GetText(context.CancellationToken).ToString().Contains("IDay"))
                .Select(day => day.GetRoot().DescendantNodes().OfType<ClassDeclarationSyntax>().FirstOrDefault())
                .Where(classDeclarationSyntax => classDeclarationSyntax != null)
                .Select(classDeclarationSyntax => classDeclarationSyntax.Identifier.ToString())
                .Where(className => className != "DayFactory");
    }
}